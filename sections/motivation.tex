\section{Insights of \mysys}

Our targeted operator programs involve some challenging patterns that hinder the effectiveness of existing constant propagation techniques.
In this section, we discuss the impact of these patterns on constant propagation and our key solution.

\subsection{Dynamic Shape Checks}

Dynamic shape operators often employ shape checks to detect invalid inputs for robustness dut to several reasons:
1) Some high-performance algorithms only support specific shapes or data layouts. 
2) Inputs may exceed resource limits for the target hardware.
Consequently, runtime shape checks are prevalent in operator implementations, especially for NPU operators, which must satisfy hardware constraints such as mandatory memory alignment, tile vloume should not exceed certain memory buffer size, etc..
These checks often locate in the beginning of tiling functions, and the error reporting path usually return an error status code and bypass the rest of the function, called \kw{early return path}.

\begin{figure}[H]
    \centering
    \hfill
    \hfill
    \begin{minipage}{0.55\textwidth}
    \begin{lstlisting}[language=C++, caption={Early return path due to dynamic shape check.}, label={lst:early_return_code}]
const int SUCCESS = 0, ERROR = -1;
int foo1(int s) {
    if(s > 1024)
        return ERROR; // fails
    return SUCCESS;
}

int foo(int s, int& t) {
    int ret = foo1(s);
    if (ret != SUCCESS) // check
        return ret; // check fails
    t = 32;
    return SUCCESS;
}
    \end{lstlisting}
    \end{minipage}
    \begin{minipage}{0.4\textwidth}
    \includegraphics[width=\textwidth]{figures/motivation/dynamic-shape-check-demo.png}
    \caption{Data flow and control flow of \autoref{lst:early_return_code}.}
    \label{fig:dynamic_shape_check_demo}
    \end{minipage}
\end{figure}

As shown in \autoref{lst:early_return_code}, the function \kw{foo} contains a dynamic shape check in the called function \kw{foo1}.
If the input shape parameter \kw{s} exceeds 1024, \kw{foo1} returns an error code, leading to an early return in \kw{foo} that bypasses the assignment of the output parameter \kw{t}.
Assume the initial value of \kw{t} is 0.
The actual trouble comes when we try to deduce the constant value of \kw{t} using constant propagation at block 3.
As shown in \autoref{fig:dynamic_shape_check_demo}, there are two possible paths to reach block 3:
1) The valid path is from block 2 where \kw{s} $\leq$ 1024, \kw{t} is assigned the constant value 32.
2) The early return path is from block 1 where \kw{s} $>$ 1024, \kw{t} remains its initial value 0.
Consequently, at block 3, \kw{t} can be either 0 or 32, making it impossible to deduce a constant value.
Although the symbolic execution technique can explore and deduce the constant value of \kw{t} along all the paths, it suffers from path explosion and is computationally expensive, making it impractical for our task.
The key here is to identify that the control flow edge from Block 1 to 3 is unreachable given valid inputs where \kw{s} $\leq$ 1024.
Given this information, we can safely ignore the early return path during constant propagation and deduce that \kw{t} is always 32 at block 3.

To address this problem, we propose a novel \textbf{early return path identification} technique.
Our insight is that the SUCCESS/ERROR status codes are all compile-time constants, thus can be used as indicators to identify early return paths.
For example, the SUCCESS code is always 0, and the ERROR code is always -1 in all the CANN built-in operator libraries.
The usage of these status codes follows a consistent pattern:
1) A function returns a status code to indicate success or failure.
2) The caller block checks the returned status code using a compare instruction. If the status code indicates failure, the caller block performs an early return.
3) The exit block of the function merges all the return paths and it often contains a PHI node to select the final return value.

Our \textbf{early return path identification} algorithm starts from the exit block of a function.
For a block, we traces back along the phi node's incoming edges
If the corresponding incoming value belongs to an ERROR code constant or the incoming edge comes froms the check failure branch, we mark this edge as an early return path.

% These observations lead to the following heuristics for identifying early return paths:
% 1) If the exit block contains a PHI node for the return value, then the incoming value from an early return path is often a constant ERROR code.
% 2) The early 