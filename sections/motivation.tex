\section{Motivation}

Our targeted operator programs involve some challenging patterns that hinder the effectiveness of existing constant propagation techniques.
In this section, we discuss the impact of these patterns on constant propagation and our key solution.

\subsection{Dynamic Shape Checks}

Dynamic shape operators often employ shape checks to detect invalid inputs for seek of robustness dut to several reasons:
1) Some high-performance algorithms only support specific shapes or data layouts. 
2) Inputs may exceed resource limits for the target hardware.
Consequently, runtime shape checks are prevalent in operator implementations, especially for NPU operators, which must satisfy stringent hardware constraints such as mandatory memory alignment, tile vloume should not exceed certain memory buffer size, etc..
These checks often locate in the beginning of tiling functions, and their error reporting paths usually return early and bypass the rest of the function, called \kw{early return paths}.

These early return paths carry significant implications for constant propagation.


% Since neither manual constant propagation nor runtime JIT compilation adequately addresses the challenges of constant specialization in operator libraries, 
% it is necessary to design a specialization framework based on static program analysis at the offline compilation stage. Existing constant propagation techniques can be broadly categorized into two primary methodologies:

% \begin{itemize}
%     \item \textbf{Data Flow Analysis (DFA):} A classic algorithm for constant propagation, DFA models the program as a Control Flow Graph (CFG) and propagates values until a fixed-point is reached. Its theoretical foundation, Abstract Interpretation, ensures soundness and termination by defining abstract value domains (e.g., \textit{Top}, \textit{Constant}, \textit{NAC}) and \texttt{join} operators. While DFA is computationally efficient, it is \textbf{path-insensitive}, leading to a loss of precision at control-flow merge points.

%     \item \textbf{Symbolic Execution (SE):} A \textbf{path-sensitive} methodology that explores individual program paths, maintaining variable states as symbolic expressions and tracking branch constraints. SE offers high precision and can identify path-dependent constants missed by DFA. However, it suffers from the \textbf{path explosion} problem, making it computationally expensive and often impractical for this task.
% \end{itemize}

% However, all these existing techniques face the same significant challenges when applied to C++-based operator libraries for the following reasons:
% \begin{itemize}
%     \item \textbf{Dynamic Shape Checks:} Operator programs are generally designed to handle a range of input shapes, thus needing to perform checks to ensure input validity. The program returns errors immediately when invalid inputs are detected, leading to .
%     These checks lead to numerous program paths, that are unreachable given valid inputs.
%     Besides, patterns of these checks are 
    
% \end{itemize}